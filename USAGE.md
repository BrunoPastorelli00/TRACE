# TRACE Usage Guide

This guide provides comprehensive documentation for using TRACE to create and verify provenance for AI-generated and AI-transformed video content.

## Table of Contents

- [Installation](#installation)
- [Quick Start](#quick-start)
- [CLI Usage](#cli-usage)
  - [Stamping Videos](#stamping-videos)
  - [Verifying Videos](#verifying-videos)
- [Programmatic API Usage](#programmatic-api-usage)
- [Key Management](#key-management)
- [Common Workflows](#common-workflows)
- [File Structure](#file-structure)
- [Troubleshooting](#troubleshooting)

---

## Installation

```bash
# Clone the repository
git clone <repository-url>
cd TRACE

# Install dependencies
npm install

# Build the project
npm run build
```

---

## Quick Start

### 1. Generate a key pair (optional)

If you don't have a key pair, TRACE will generate one automatically when you stamp a video. To generate one manually:

```bash
# The CLI will auto-generate keys, but you can also use the API (see below)
```

### 2. Stamp a video

```bash
npm run stamp -- video.mp4 \
  --operation ai_generated \
  --provider-id "my-ai-service" \
  --provider-name "My AI Service" \
  --model-id "video-generator-v1" \
  --model-version "1.0.0"
```

This creates:
- `video.prov.json` - The provenance manifest
- `video.prov.sig` - The cryptographic signature

### 3. Verify a video

```bash
npm run verify -- video.mp4
```

---

## CLI Usage

### Stamping Videos

The `trace-stamp` command creates provenance manifests for video files.

#### Basic Syntax

```bash
npm run stamp -- <video-file> [options]
```

or if installed globally:

```bash
trace-stamp <video-file> [options]
```

#### Required Options

| Option | Description | Example |
|--------|-------------|---------|
| `-o, --operation <operation>` | Operation type: `ai_generated` or `ai_transformed` | `--operation ai_generated` |
| `--provider-id <id>` | Unique identifier for the provider (e.g., service name, domain) | `--provider-id "acme-ai"` |
| `--provider-name <name>` | Human-readable provider name | `--provider-name "ACME AI Service"` |
| `--model-id <id>` | Model identifier | `--model-id "video-gen-model"` |
| `--model-version <version>` | Model version string | `--model-version "1.2.3"` |

#### Optional Options

| Option | Description | Example |
|--------|-------------|---------|
| `-k, --key <path>` | Path to private key file (generates new key if not provided) | `--key ./keys/private.pem` |
| `--provider-key <path>` | Path to provider public key file (extracted from private key if not provided) | `--provider-key ./keys/public.pem` |
| `--input-hash <hash>` | Input hash for transformation operations (must be in `sha256:...` format) | `--input-hash "sha256:abc123..."` |
| `--embed` | Embed manifest and signature in video container metadata (optional, sidecar files are always created) | `--embed` |

#### Operation Types

- **`ai_generated`**: Use when the video was entirely generated by AI
- **`ai_transformed`**: Use when an existing video was transformed/modified by AI

#### Examples

**Stamping an AI-generated video:**

```bash
npm run stamp -- output.mp4 \
  --operation ai_generated \
  --provider-id "example-provider" \
  --provider-name "Example AI Provider" \
  --model-id "video-model-v1" \
  --model-version "1.0.0"
```

**Stamping an AI-transformed video (with input hash):**

```bash
npm run stamp -- transformed.mp4 \
  --operation ai_transformed \
  --provider-id "example-provider" \
  --provider-name "Example AI Provider" \
  --model-id "video-model-v1" \
  --model-version "1.0.0" \
  --input-hash "sha256:7d865e959b2466918c9863afca942d0fb89d7c9ac0c99bafc3749504ded97730"
```

**Using a custom key file:**

```bash
npm run stamp -- video.mp4 \
  --operation ai_generated \
  --provider-id "example-provider" \
  --provider-name "Example AI Provider" \
  --model-id "video-model-v1" \
  --model-version "1.0.0" \
  --key ./production-key.pem
```

**Embedding metadata in video container (optional):**

```bash
npm run stamp -- video.mp4 \
  --operation ai_generated \
  --provider-id "example-provider" \
  --provider-name "Example AI Provider" \
  --model-id "video-model-v1" \
  --model-version "1.0.0" \
  --embed
```

This will:
1. Create sidecar files (`.prov.json` and `.prov.sig`) - **always done**
2. Embed the manifest and signature in the video container metadata - **optional**
3. Verification will prefer embedded metadata, falling back to sidecar files if not found

**Obtaining input hash for transformations:**

If you're transforming an existing video, first compute its hash:

```bash
# Using Node.js (after importing the library)
node -e "const { computeFileHash } = require('./dist/index.js'); console.log(computeFileHash('input.mp4'));"
```

### Verifying Videos

The `trace-verify` command verifies the provenance of a video file.

#### How Verification Works

TRACE verification supports reading provenance data from **two sources** (in priority order):

1. **Embedded metadata** in the video container (if available)
2. **Sidecar files** (`.prov.json` and `.prov.sig`) - fallback

The verification process:

1. **First tries to extract** manifest and signature from embedded video metadata
2. **Falls back to sidecar files** if embedded metadata is not found
3. **Verifies the cryptographic signature** of the manifest
4. **Computes the hash** of the video file
5. **Compares the computed hash** with the hash stored in the manifest
6. **Returns a verification result** (VALID, INVALID, or INCONCLUSIVE)

The verification message will indicate the source: `"Provenance verified successfully (from embedded metadata)"` or `"Provenance verified successfully (from sidecar files)"`.

> **Note**: Sidecar files are always created during stamping (mandatory for v0.1). Embedding in container metadata is optional and can be enabled with the `--embed` flag.

#### Basic Syntax

```bash
npm run verify -- <video-file> [options]
```

or if installed globally:

```bash
trace-verify <video-file> [options]
```

#### Options

| Option | Description | Example |
|--------|-------------|---------|
| `-m, --manifest <path>` | Path to manifest file (auto-detected if not provided) | `--manifest video.prov.json` |
| `-s, --signature <path>` | Path to signature file (auto-detected if not provided) | `--signature video.prov.sig` |

#### Examples

**Basic verification (tries embedded metadata first, then sidecar files):**

```bash
npm run verify -- video.mp4
```

This automatically:
1. **Tries to extract** manifest and signature from embedded video metadata
2. **Falls back to** sidecar files if embedded metadata is not found:
   - `video.prov.json` (manifest)
   - `video.prov.sig` (signature)

**Verification with explicit paths:**

```bash
npm run verify -- video.mp4 \
  --manifest ./manifests/video.prov.json \
  --signature ./signatures/video.prov.sig
```

#### Verification Results

The verification command returns one of three results:

- **`VALID`**: Provenance present and cryptographically verified
  - The manifest and signature were found and read from sidecar files
  - The signature is cryptographically valid
  - The video file hash matches the hash stored in the manifest
  - The provenance chain is intact

- **`INVALID`**: Provenance present but invalid or tampered
  - Signature verification failed (manifest was modified or wrong key), OR
  - File hash mismatch (video file was modified after stamping)

- **`INCONCLUSIVE`**: Provenance missing or unverifiable
  - Manifest or signature sidecar files not found
  - Video file not found
  - Other verification errors (corrupted files, parsing errors, etc.)

---

## Programmatic API Usage

TRACE can also be used programmatically in your Node.js/TypeScript applications.

### Installation

```bash
npm install <package-name>  # Or import from local build
```

### Basic Usage

```typescript
import {
  createManifest,
  verifyManifest,
  saveSidecarFiles,
  getSidecarPaths,
  generateKeyPair,
  computeFileHash,
  type Operation,
  type Provider,
  type Model,
  type VerificationResult
} from 'trace';
```

### Generating Key Pairs

```typescript
const { privateKey, publicKey } = generateKeyPair();

// Save keys securely
import { writeFileSync } from 'fs';
writeFileSync('private-key.pem', privateKey);
writeFileSync('public-key.pem', publicKey);
```

### Stamping a Video Programmatically

```typescript
import { readFileSync } from 'fs';

// Load your private key
const privateKey = readFileSync('private-key.pem', 'utf-8');

// Define provider and model information
const provider: Provider = {
  id: 'my-ai-service',
  name: 'My AI Service',
  public_key: Buffer.from(publicKey).toString('base64')
};

const model: Model = {
  id: 'video-generator-v1',
  version: '1.0.0'
};

// Create manifest and signature
const { manifest, signature } = createManifest(
  'output.mp4',
  'ai_generated',  // or 'ai_transformed'
  provider,
  model,
  privateKey,
  null  // inputHash (null for ai_generated, or sha256:... for ai_transformed)
);

// Save sidecar files
saveSidecarFiles('output.mp4', manifest, signature);

console.log('Provenance manifest created successfully');
```

### Transforming a Video with Input Hash

```typescript
// First, compute hash of the input video
const inputHash = computeFileHash('input.mp4');

// Then create manifest for transformed output
const { manifest, signature } = createManifest(
  'transformed.mp4',
  'ai_transformed',
  provider,
  model,
  privateKey,
  inputHash  // Include input hash for transformations
);

saveSidecarFiles('transformed.mp4', manifest, signature);
```

### Verifying a Video Programmatically

**Note**: Verification reads from sidecar files, not from embedded video metadata.

```typescript
// Get paths to sidecar files (same directory as video)
const { manifestPath, signaturePath } = getSidecarPaths('video.mp4');

// Verify the video
// - Reads manifest from manifestPath (sidecar file)
// - Reads signature from signaturePath (sidecar file)
// - Computes hash of video.mp4 and compares with manifest
const { result, message } = verifyManifest(
  'video.mp4',      // Used for hash computation only
  manifestPath,     // Read from sidecar file
  signaturePath     // Read from sidecar file
);

switch (result) {
  case 'VALID':
    console.log('✓ Provenance verified:', message);
    break;
  case 'INVALID':
    console.error('✗ Provenance invalid:', message);
    break;
  case 'INCONCLUSIVE':
    console.warn('? Verification inconclusive:', message);
    break;
}
```

### Complete Example: Video Processing Pipeline

```typescript
import {
  createManifest,
  saveSidecarFiles,
  verifyManifest,
  getSidecarPaths,
  computeFileHash,
  generateKeyPair,
  type Operation
} from 'trace';
import { readFileSync, writeFileSync } from 'fs';

// Setup: Generate or load keys
let privateKey: string;
let publicKey: string;

try {
  privateKey = readFileSync('keys/private.pem', 'utf-8');
  publicKey = readFileSync('keys/public.pem', 'utf-8');
} catch {
  console.log('Generating new key pair...');
  const keyPair = generateKeyPair();
  privateKey = keyPair.privateKey;
  publicKey = keyPair.publicKey;
  writeFileSync('keys/private.pem', privateKey);
  writeFileSync('keys/public.pem', publicKey);
}

// Define provider and model
const provider = {
  id: 'my-ai-service',
  name: 'My AI Service',
  public_key: Buffer.from(publicKey).toString('base64')
};

const model = {
  id: 'video-model-v1',
  version: '1.0.0'
};

// Process AI-generated video
async function processGeneratedVideo(videoPath: string) {
  console.log(`Stamping ${videoPath}...`);
  
  const { manifest, signature } = createManifest(
    videoPath,
    'ai_generated',
    provider,
    model,
    privateKey
  );
  
  saveSidecarFiles(videoPath, manifest, signature);
  console.log('✓ Stamped successfully');
}

// Process AI-transformed video
async function processTransformedVideo(inputPath: string, outputPath: string) {
  console.log(`Stamping transformation: ${inputPath} -> ${outputPath}...`);
  
  // Compute input hash
  const inputHash = computeFileHash(inputPath);
  console.log(`Input hash: ${inputHash}`);
  
  // Create manifest for output
  const { manifest, signature } = createManifest(
    outputPath,
    'ai_transformed',
    provider,
    model,
    privateKey,
    inputHash
  );
  
  saveSidecarFiles(outputPath, manifest, signature);
  console.log('✓ Stamped successfully');
}

// Verify a video
async function verifyVideo(videoPath: string) {
  console.log(`Verifying ${videoPath}...`);
  
  const { manifestPath, signaturePath } = getSidecarPaths(videoPath);
  const { result, message } = verifyManifest(videoPath, manifestPath, signaturePath);
  
  console.log(`Result: ${result}`);
  console.log(`Message: ${message}`);
  
  return result === 'VALID';
}
```

---

## Key Management

### Generating Keys

TRACE uses Ed25519 key pairs for signing. You can generate keys in several ways:

**1. Automatic generation (CLI):**

```bash
# Keys are auto-generated if not provided
npm run stamp -- video.mp4 ... --key ./my-key.pem
# Creates: my-key.pem and my-key.pub.pem
```

**2. Programmatic generation:**

```typescript
import { generateKeyPair, writeFileSync } from 'trace';

const { privateKey, publicKey } = generateKeyPair();
writeFileSync('private.pem', privateKey);
writeFileSync('public.pem', publicKey);
```

**3. Extract public key from private key:**

```typescript
import { createPublicKey } from 'crypto';
import { readFileSync } from 'fs';

const privateKey = readFileSync('private.pem', 'utf-8');
const publicKeyObj = createPublicKey({ key: privateKey, format: 'pem' });
const publicKeyPem = publicKeyObj.export({ format: 'pem', type: 'spki' }) as string;
```

### Best Practices

1. **Store private keys securely**: Never commit private keys to version control
2. **Use different keys per environment**: Production, staging, and development should use separate keys
3. **Backup keys**: Store private keys in secure, encrypted backup locations
4. **Key rotation**: Plan for key rotation if needed (future feature)
5. **Access control**: Limit access to private keys to authorized personnel only

### Environment Variables

For production use, consider loading keys from environment variables:

```typescript
import { readFileSync } from 'fs';

const privateKey = process.env.TRACE_PRIVATE_KEY || 
  readFileSync(process.env.TRACE_PRIVATE_KEY_PATH || 'default-key.pem', 'utf-8');
```

---

## Common Workflows

### Workflow 1: AI Video Generation Service

A service that generates videos using AI and needs to stamp them:

```bash
#!/bin/bash
# generate-video.sh

VIDEO_OUTPUT="output.mp4"
PROVIDER_ID="my-video-ai"
PROVIDER_NAME="My Video AI Service"
MODEL_ID="video-gen-v2"
MODEL_VERSION="2.1.0"

# Generate video (your AI service code)
# ... video generation happens here ...

# Stamp the generated video
npm run stamp -- "$VIDEO_OUTPUT" \
  --operation ai_generated \
  --provider-id "$PROVIDER_ID" \
  --provider-name "$PROVIDER_NAME" \
  --model-id "$MODEL_ID" \
  --model-version "$MODEL_VERSION" \
  --key /secure/path/production-key.pem

echo "Generated and stamped: $VIDEO_OUTPUT"
```

### Workflow 2: Video Transformation Pipeline

A pipeline that transforms existing videos:

```bash
#!/bin/bash
# transform-video.sh

INPUT_VIDEO="input.mp4"
OUTPUT_VIDEO="transformed.mp4"

# Transform video (your transformation code)
# ... transformation happens here ...

# Compute input hash
INPUT_HASH=$(node -e "const { computeFileHash } = require('./dist/index.js'); console.log(computeFileHash('$INPUT_VIDEO'));")

# Stamp the transformed video
npm run stamp -- "$OUTPUT_VIDEO" \
  --operation ai_transformed \
  --provider-id "transformer-service" \
  --provider-name "Video Transformer Service" \
  --model-id "enhancement-model" \
  --model-version "1.0.0" \
  --input-hash "$INPUT_HASH"

echo "Transformed and stamped: $OUTPUT_VIDEO"
```

### Workflow 3: Verification Service

A service that verifies videos submitted by users:

```typescript
import { verifyManifest, getSidecarPaths } from 'trace';
import { existsSync } from 'fs';

async function verifyUserUpload(videoPath: string): Promise<{
  valid: boolean;
  result: string;
  message: string;
}> {
  const { manifestPath, signaturePath } = getSidecarPaths(videoPath);
  
  if (!existsSync(manifestPath) || !existsSync(signaturePath)) {
    return {
      valid: false,
      result: 'INCONCLUSIVE',
      message: 'Provenance files not found'
    };
  }
  
  const { result, message } = verifyManifest(videoPath, manifestPath, signaturePath);
  
  return {
    valid: result === 'VALID',
    result,
    message
  };
}

// Usage
const verification = await verifyUserUpload('user-upload.mp4');
if (verification.valid) {
  console.log('✓ Video provenance verified');
} else {
  console.log(`✗ Verification failed: ${verification.message}`);
}
```

---

## File Structure

After stamping a video, TRACE creates **sidecar files** alongside the video:

```
video.mp4              # Original video file
video.prov.json        # Provenance manifest (JSON) - stored separately
video.prov.sig         # Cryptographic signature (base64) - stored separately
```

### Metadata Storage

**Implementation (v0.1):**

**Sidecar Files (Mandatory):**
- Provenance data is **always stored** in sidecar files (`.prov.json` and `.prov.sig`)
- These files are mandatory for v0.1 compliance
- They are created in the same directory as the video file

**Embedded Metadata (Optional):**
- Provenance can be **optionally embedded** in video container metadata using the `--embed` flag
- Supported formats: MP4 (UUID box) and WebM (custom tag)
- Embedded metadata survives file renaming but **can be removed by re-encoding**
- Verification tries embedded metadata first, then falls back to sidecar files

**Why Sidecar Files?**
- Sidecar files are the **canonical attachment mechanism** for TRACE v0.1
- They ensure provenance data is always accessible and verifiable
- They don't modify the video file, preserving compatibility with all players
- They can be easily transferred alongside the video file

### Manifest Structure

The `*.prov.json` file contains a JSON manifest with the following structure:

```json
{
  "spec_version": "0.1",
  "media_profile": "video",
  "provider": {
    "id": "example-provider",
    "name": "Example Provider",
    "public_key": "base64-encoded-public-key"
  },
  "operation": "ai_generated",
  "model": {
    "id": "model-id",
    "version": "1.0.0"
  },
  "timestamps": {
    "created_utc": "2024-01-01T12:00:00.000Z"
  },
  "input": {
    "hash": null
  },
  "output": {
    "hash": "sha256:...",
    "media_type": "video/mp4"
  },
  "claims": ["ai_generated"],
  "nonce": "random-hex-string"
}
```

### Signature File

The `*.prov.sig` file contains the base64-encoded Ed25519 signature of the canonical JSON manifest.

---

## Troubleshooting

### Common Issues

#### 1. "Manifest file not found" or "Signature file not found" (INCONCLUSIVE)

**Problem**: Neither embedded metadata nor sidecar files were found.

**Possible causes**:
- The video was never stamped
- The sidecar files were deleted or not transferred with the video
- The video file was moved without the sidecar files
- Embedded metadata was removed (e.g., by re-encoding)

**Solution**: 
- Ensure the video was stamped first: `npm run stamp -- video.mp4 ...`
- Check that sidecar files exist in the same directory as the video
- If files were moved, ensure all three files (video, manifest, signature) were moved together
- If you used `--embed`, the metadata might have been removed during re-encoding - use sidecar files instead

#### 2. "Video file not found"

**Problem**: The specified video file doesn't exist.

**Solution**: Check the file path and ensure the file exists:
```bash
ls -la video.mp4
npm run verify -- ./correct/path/video.mp4
```

#### 3. "Invalid operation"

**Problem**: The operation type is not `ai_generated` or `ai_transformed`.

**Solution**: Use exactly one of these values:
```bash
--operation ai_generated   # ✓ Correct
--operation ai_transformed # ✓ Correct
--operation generated      # ✗ Incorrect
```

#### 4. "Input hash must be in sha256:... format"

**Problem**: Input hash doesn't start with `sha256:` prefix.

**Solution**: Ensure the hash is prefixed correctly:
```bash
--input-hash "sha256:7d865e959b2466918c9863afca942d0fb89d7c9ac0c99bafc3749504ded97730"  # ✓ Correct
--input-hash "7d865e959b2466918c9863afca942d0fb89d7c9ac0c99bafc3749504ded97730"         # ✗ Incorrect
```

#### 5. "Signature verification failed" (INVALID)

**Problem**: The signature doesn't match the manifest or the wrong key was used.

**Possible causes**:
- Manifest was modified after signing
- Wrong private key was used for signing
- Signature file was corrupted

**Solution**: Re-stamp the video with the correct key.

#### 6. "File hash mismatch" (INVALID)

**Problem**: The video file was modified after stamping.

**Possible causes**:
- Video file was re-encoded or edited
- File was corrupted during transfer
- Different version of the file

**Solution**: Re-stamp the video after the final encoding.

#### 7. "Manifest file not found" or "Signature file not found" (INCONCLUSIVE)

**Problem**: The sidecar files don't exist or are in the wrong location.

**Solution**: 
- Ensure the video was stamped first: `npm run stamp -- video.mp4 ...`
- Check that `.prov.json` and `.prov.sig` files exist alongside the video file
- Verify you're checking the correct directory

#### 8. Key generation issues

**Problem**: Unable to generate or use keys.

**Solution**: Check file permissions and ensure Node.js crypto module is available:
```bash
node -e "console.log(require('crypto').generateKeyPairSync('ed25519'))"
```

### Debug Mode

For more detailed error messages, you can add debug logging:

```typescript
try {
  const { manifest, signature } = createManifest(...);
} catch (error) {
  console.error('Error details:', error);
  if (error instanceof Error) {
    console.error('Stack trace:', error.stack);
  }
  throw error;
}
```

### Getting Help

If you encounter issues not covered here:

1. Check the [specification](../spec/trace-spec-v0.1.md) for protocol details
2. Review the [examples](../examples/) directory
3. Check the [contributing guide](../CONTRIBUTING.md)
4. Open an issue on the repository

---

## Next Steps

- Read the [TRACE Specification](../spec/trace-spec-v0.1.md) for protocol details
- Explore the [examples](../examples/) directory
- Check out [CONTRIBUTING.md](../CONTRIBUTING.md) to contribute improvements

